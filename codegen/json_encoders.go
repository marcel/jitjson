package codegen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

type JSONEncoders struct {
	Directory string
	Package   string
	bytes.Buffer
	structValue               reflect.Value
	definedMarshalerInterface map[string]bool
}

func NewJSONEncoders(directory string, packageName string) *JSONEncoders {
	definedMarshalerInterface := make(map[string]bool)
	return &JSONEncoders{
		Directory:                 directory,
		Package:                   packageName,
		definedMarshalerInterface: definedMarshalerInterface,
	}
}

func (c *JSONEncoders) PackageDeclaration() {
	c.WriteString(fmt.Sprintf("// Auto-generated by jitjson\npackage %s\n\n", c.Package))
}

func (c *JSONEncoders) ImportDeclaration() {
	c.WriteString("import \"encoding/json\"\n")
	c.WriteString("import \"github.com/marcel/jitjson/encoding\"\n\n")
}

// TODO Add func NewEncodingBuffer to wrap bufferPool.GetBuffer()
func (c *JSONEncoders) SetBufferPoolVar() {
	c.WriteString("var bufferPool = encoding.NewSyncPool(4096)\n\n")
}

func (c *JSONEncoders) EncodingBufferStructWrapper() {
	c.WriteString("type encodingBuffer struct {\n\t*encoding.Buffer\n}\n\n")
}

var jsonMarshalerType = reflect.TypeOf(new(json.Marshaler)).Elem()

// TODO Extract to struct maybe
func (c *JSONEncoders) JSONMarshalerInterfaceFor(jsonStruct interface{}) {
	value := reflect.ValueOf(jsonStruct)

	if value.Kind() != reflect.Struct {
		return
	}

	if value.Type().Implements(jsonMarshalerType) ||
		reflect.PtrTo(value.Type()).Implements(jsonMarshalerType) {
		return
	}

	structName := value.Type().Name()

	if c.marshalerInterfaceAlreadyDefined(structName) {
		return
	}

	c.jsonMarshalerInterfaceFor(structName)
	c.definedMarshalerInterface[structName] = true
}

func (c *JSONEncoders) jsonMarshalerInterfaceFor(structName string) {
	c.WriteString(fmt.Sprintf("func (s %s) MarshalJSON() ([]byte, error) {\n", structName))
	c.WriteString("\tunderlying := bufferPool.Get()\n")
	c.WriteString("\tbuf := encodingBuffer{Buffer: underlying}\n")
	c.WriteString("\tdefer func() {\n")
	c.WriteString("\t\tbufferPool.Put(underlying)\n")
	c.WriteString("\t}()\n\n")

	c.WriteString(fmt.Sprintf("\tbuf.%sStruct(s)\n", c.lowerCase(structName)))
	c.WriteString("\treturn buf.Bytes(), nil\n")
	c.WriteString("}\n\n")
}

func (c *JSONEncoders) marshalerInterfaceAlreadyDefined(structName string) bool {
	isDefined, _ := c.definedMarshalerInterface[structName]

	return isDefined
}

var JSONEncodersTargetFile = "json_encoders.go"

func (c *JSONEncoders) WriteFile() error {
	targetPath := filepath.Join(c.Directory, JSONEncodersTargetFile)

	return ioutil.WriteFile(targetPath, c.Formatted(), 0644)
}

func (c *JSONEncoders) Formatted() []byte {
	tmpFile, err := ioutil.TempFile("", "gofmtinput")
	defer os.Remove(tmpFile.Name())

	if _, err = tmpFile.Write(c.Bytes()); err != nil {
		return c.Bytes()
	}

	if tmpFile.Close() != nil {
		return c.Bytes()
	}

	out := new(bytes.Buffer)

	cmd := exec.Command("goimports", tmpFile.Name())
	cmd.Stdout = out

	if err = cmd.Run(); err != nil {
		return c.Bytes()
	}

	return out.Bytes()
}

type encodableStructSpec struct {
	value      reflect.Value
	jsonFields []reflect.StructField
}

func newEncodableStructSpec(value reflect.Value) *encodableStructSpec {
	return &encodableStructSpec{value, []reflect.StructField{}}
}

func (c *JSONEncoders) EncoderMethodFor(jsonStruct interface{}) error {
	value := reflect.ValueOf(jsonStruct)

	var structSpec *encodableStructSpec

	switch value.Kind() {
	default:
		return fmt.Errorf("EncoderMethodFor: unsupported kind '%s'", value.Kind().String())
	case reflect.Ptr:
		return c.EncoderMethodFor(value.Elem().Interface())
	case reflect.Struct:
		structSpec = newEncodableStructSpec(value)
		for i := 0; i < value.NumField(); i++ {
			// TODO Handled structField.Anonymous == true
			structField := value.Type().Field(i)

			if _, ok := structField.Tag.Lookup("json"); ok {
				structSpec.jsonFields = append(structSpec.jsonFields, structField)
			}
		}
	}

	if len(structSpec.jsonFields) == 0 {
		return nil
	}

	c.generateMethodForStruct(structSpec)

	return nil
}

func (c *JSONEncoders) generateMethodForStruct(structSpec *encodableStructSpec) {
	c.structValue = structSpec.value

	c.methodDeclaration()

	c.encoderInvoke("OpenBrace")

	for index, field := range structSpec.jsonFields {
		if index != 0 {
			c.encoderInvoke("Comma")
		}
		c.fieldEncodingFor(field)
	}

	c.WriteString("\n")
	c.encoderInvoke("CloseBrace")
	c.endMethod()
}

func (c *JSONEncoders) encoderInvoke(method string) {
	c.WriteString(fmt.Sprintf("\te.%s()\n", method))
}

func (c *JSONEncoders) methodDeclaration() {
	methodDecl := fmt.Sprintf(
		"func (e *encodingBuffer) %sStruct(%s %s) {\n",
		c.structName(), c.structName(), c.structTypeName(),
	)

	c.WriteString(methodDecl)
}

func (c *JSONEncoders) attributeName(field reflect.StructField) {
	var attrName string

	attrName = field.Tag.Get("json")
	if attrName == "" {
		attrName = strings.ToLower(field.Name)
	}

	quotedAttr := strconv.Quote(attrName) + ":"
	c.WriteString(fmt.Sprintf("\n\t// %s\n\te.Write(%#v)\n", quotedAttr, []byte(quotedAttr)))
}

// TODO Extract everything that needs to be passed a field into
// methods of this struct
type FieldEncoder struct {
	field   reflect.StructField
	encoder *JSONEncoders
}

func (c *JSONEncoders) fieldEncodingFor(field reflect.StructField) {
	c.attributeName(field)

	switch field.Type.Kind() {
	default:
		log.Println("Unsupported field kind", field.Type.Kind())
	case reflect.Interface:
		c.fallbackToJSONMarshal(field)
	case reflect.Ptr:
		c.ptrFieldEncoding(field)
	case reflect.Bool:
		c.invokeEncoderForFieldType("Bool", field)
	case reflect.String:
		c.stringFieldEncoding(field)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		c.intFieldEncoding(field)
	case reflect.Float32, reflect.Float64:
		c.floatFieldEncoding(field)
	case reflect.Struct:
		c.structFieldEncoding(field)
	case reflect.Slice, reflect.Array:
		c.sliceFieldEncoding(field)
	case reflect.Map:
		c.mapFieldEncoding(field)
	}
}

func (c *JSONEncoders) ptrFieldEncoding(field reflect.StructField) {
	c.encoderForElementType(field.Type.Elem(), "*"+c.dispatch(field))
}

func (c *JSONEncoders) dispatch(field reflect.StructField) string {
	return fmt.Sprintf("%s.%s", c.structName(), field.Name)
}

func (c *JSONEncoders) stringFieldEncoding(field reflect.StructField) {
	c.invokeEncoderForFieldType("Quote", field)
}

func (c *JSONEncoders) intFieldEncoding(field reflect.StructField) {
	var specializedIntEncoder string

	switch field.Type.Kind() {
	case reflect.Int64:
		specializedIntEncoder = "Int64"
	case reflect.Uint64:
		specializedIntEncoder = "Uint64"
	case reflect.Int32:
		specializedIntEncoder = "Int32"
	case reflect.Uint32:
		specializedIntEncoder = "Uint32"
	case reflect.Int16:
		specializedIntEncoder = "Int16"
	case reflect.Uint16:
		specializedIntEncoder = "Uint16"
	case reflect.Int8:
		specializedIntEncoder = "Int8"
	case reflect.Uint8:
		specializedIntEncoder = "Uint8"
	case reflect.Int:
		specializedIntEncoder = "Int"
	case reflect.Uint:
		specializedIntEncoder = "Uint"
	}

	var code string
	if field.Type.String() == field.Type.Kind().String() {
		code = fmt.Sprintf("\te.%s(%s)\n",
			specializedIntEncoder, c.dispatch(field))
	} else {
		code = fmt.Sprintf("\te.%s(%s(%s))\n",
			specializedIntEncoder, strings.ToLower(specializedIntEncoder), c.dispatch(field))
	}
	c.WriteString(code)
}

func (c *JSONEncoders) floatFieldEncoding(field reflect.StructField) {
	var specializedFloatEncoder string

	switch field.Type.Kind() {
	case reflect.Float64:
		specializedFloatEncoder = "Float64"
	case reflect.Float32:
		specializedFloatEncoder = "Float32"
	}

	code := fmt.Sprintf("\te.%s(%s(%s))\n",
		specializedFloatEncoder, strings.ToLower(specializedFloatEncoder), c.dispatch(field))

	c.WriteString(code)

}

func (c *JSONEncoders) pkgPath() string {
	parts := strings.Split(c.Directory, "/src/")

	return parts[len(parts)-1]
}

func (c *JSONEncoders) marshalJSONForReceiver(receiver string) {
	returnVariable := strings.Split(receiver, ".")[0]
	c.WriteString(fmt.Sprintf("\t%sBytes, err := %s.MarshalJSON()\n", returnVariable, receiver))
	c.WriteString("\tif err != nil {\n\t\tpanic(err)\n\t}\n")
	c.WriteString(fmt.Sprintf("\te.Write(%sBytes)\n", returnVariable))
}

func (c *JSONEncoders) fromCurrentPackage(t reflect.Type) bool {
	return c.pkgPath() == t.PkgPath()
}

func (c *JSONEncoders) structFieldEncoding(field reflect.StructField) {
	if field.Type.Implements(jsonMarshalerType) {
		c.marshalJSONForReceiver(c.dispatch(field))
		return
	}

	if !c.fromCurrentPackage(field.Type) {
		c.fallbackToJSONMarshal(field)
		return
	}

	targetStruct := strings.ToLower(field.Type.Name())

	// TODO extract this to a method so encoderForElementType can reuse it
	code := fmt.Sprintf("\te.%sStruct(%s)\n", targetStruct, c.dispatch(field))
	c.WriteString(code)
}

func (c *JSONEncoders) fallbackToJSONMarshal(field reflect.StructField) {
	targetStruct := strings.ToLower(field.Type.Name())
	c.jsonMarshal(targetStruct, c.dispatch(field))
}

func (c *JSONEncoders) jsonMarshal(assignTo string, variableName string) {
	c.WriteString(fmt.Sprintf("\t%sBytes, _ := json.Marshal(%s)\n", assignTo, variableName))
	c.WriteString(fmt.Sprintf("\te.Write(%sBytes)\n", assignTo))
}

func (c *JSONEncoders) lowerCase(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func (c *JSONEncoders) sliceFieldEncoding(field reflect.StructField) {
	c.sliceEncoding(field.Type, "element", c.dispatch(field))
}

func (c *JSONEncoders) mapFieldEncoding(field reflect.StructField) {
	c.mapEncoding(field.Type, "k", "v", c.dispatch(field))
}

func (c *JSONEncoders) sliceEncoding(sliceType reflect.Type, elementName string, sliceName string) {
	c.WriteString("\te.WriteByte('[')\n")
	forLoopLine := fmt.Sprintf(
		"\tfor index, %s := range %s {\n", elementName, sliceName,
	)

	c.WriteString(forLoopLine)
	c.WriteString("\t\tif index != 0 { e.Comma() }\n")

	elementType := sliceType.Elem()
	c.encoderForElementType(elementType, elementName)

	c.WriteString("\t}\n")
	c.WriteString("\te.WriteByte(']')\n")
}

func (c *JSONEncoders) mapEncoding(mapType reflect.Type, keyName string, valueName string, mapName string) {
	c.WriteString("\t e.WriteByte('{')\n")

	var prefix string

	if parts := strings.Split(mapName, "."); len(parts) == 2 {
		prefix = c.lowerCase(parts[1])
	} else {
		prefix = mapName
	}

	iterationVar := fmt.Sprintf("%sIterationCount", prefix)

	c.WriteString(fmt.Sprintf("\t%s := 0\n", iterationVar))
	forLoopLine := fmt.Sprintf("\tfor %s, %s := range %s {\n", keyName, valueName, mapName)
	c.WriteString(forLoopLine)
	c.WriteString(fmt.Sprintf("\t\tif %s > 0 { e.Comma() }\n", iterationVar))
	c.WriteString(fmt.Sprintf("\t\t%s++\n", iterationVar))

	keyType := mapType.Key()
	valueType := mapType.Elem()

	c.encoderForElementType(keyType, keyName)
	c.WriteString("\te.WriteByte(':')\n")
	c.encoderForElementType(valueType, valueName)

	c.WriteString("\t}\n")
	c.WriteString("\t e.WriteByte('}')\n")
}

func (c *JSONEncoders) encoderForElementType(elementType reflect.Type, elementVar string) {
	switch elementType.Kind() {
	case reflect.Interface:
		c.jsonMarshal("unknownType", elementVar)
	case reflect.Struct:
		if elementType.Implements(jsonMarshalerType) {
			c.marshalJSONForReceiver(elementVar)
			return
		}
		structName := c.lowerCase(elementType.Name())
		code := fmt.Sprintf("\t\te.%sStruct(%s)\n", structName, elementVar)
		c.WriteString(code)
	case reflect.Ptr:
		c.encoderForElementType(elementType.Elem(), "*"+elementVar)
	case reflect.Slice, reflect.Array:
		subElementVar := "sub" + elementVar
		c.sliceEncoding(elementType, subElementVar, elementVar)
	case reflect.Map:
		c.mapEncoding(elementType, "subV", "subK", elementVar)
	default:
		var code string
		// TODO get rid of this special case to work around Quote() asymetry
		if elementType.Kind() == reflect.String {
			code = fmt.Sprintf("\t\te.Quote(string(%s))\n", elementVar)
		} else {
			encoderFromKind := strings.Title(elementType.Kind().String())
			code = fmt.Sprintf("\t\te.%s(%s(%s))\n", encoderFromKind, strings.ToLower(encoderFromKind), elementVar)
		}
		c.WriteString(code)
	}
}

func (c *JSONEncoders) invokeEncoderForFieldType(fieldType string, field reflect.StructField) {
	var code string

	if field.Type.Kind() == reflect.String {
		if field.Type.String() == field.Type.Kind().String() {
			code = fmt.Sprintf("\te.%s(%s)\n", fieldType, c.dispatch(field))
		} else {
			code = fmt.Sprintf("\te.%s(string(%s))\n", fieldType, c.dispatch(field))
		}
	} else {
		code = fmt.Sprintf("\te.%s(%s(%s))\n", fieldType, strings.ToLower(fieldType), c.dispatch(field))
	}
	c.WriteString(code)
}

func (c *JSONEncoders) endMethod() {
	c.WriteString("}\n\n")
}

func (c *JSONEncoders) structTypeName() string {
	return c.structValue.Type().Name()
}

func (c *JSONEncoders) structName() string {
	name := c.structTypeName()
	if name == "" {
		return "unknown"
	}
	return c.lowerCase(name)
}
