package codegen

import (
	"net"
	"testing"

	"github.com/stretchr/testify/suite"
)

type JSONEncodersTestSuite struct {
	suite.Suite
	generator *JSONEncoders
}

func TestJSONEncodersTestSuite(t *testing.T) {
	suite.Run(t, new(JSONEncodersTestSuite))
}

func (s *JSONEncodersTestSuite) SetupTest() {
	s.generator = NewJSONEncoders("somedir", "somepackage")
}

func (s *JSONEncodersTestSuite) TestPackageDeclaration() {
	s.generator.PackageDeclaration()
	s.Contains(s.generator.String(), "// Auto-generated by jitjson\npackage somepackage")
}

func (s *JSONEncodersTestSuite) TestImportDeclaration() {
	s.generator.ImportDeclaration()
	s.Equal("import \"encoding/json\"\nimport \"github.com/marcel/jitjson/encoding\"\n\n", s.generator.String())
}

func (s *JSONEncodersTestSuite) TestEncodingBufferStructWrapper() {
	s.generator.EncodingBufferStructWrapper()

	expected :=
		`type encodingBuffer struct {
	*encoding.Buffer
}

`

	s.Equal(expected, s.generator.String())
}

func (s *JSONEncodersTestSuite) TestJSONMarshlerInterface() {
	s.generator.JSONMarshalerInterfaceFor(TestJSONStruct{})

	expected :=
		`func (s TestJSONStruct) MarshalJSON() ([]byte, error) {
	underlying := bufferPool.Get()
	buf := encodingBuffer{Buffer: underlying}
	defer func() {
		bufferPool.Put(underlying)
	}()

	buf.testJSONStructStruct(s)
	return buf.Bytes(), nil
}

`
	s.Equal(expected, s.generator.String())
}

// TODO TestWriteFile

type TestJSONStruct struct {
	SomeBool                 bool                                        `json:"some_bool"`
	SomeInt                  int                                         `json:"some_int"`
	SomeInt8                 int8                                        `json:"some_int_8"`
	SomeInt16                int16                                       `json:"some_int_16"`
	SomeInt32                int32                                       `json:"some_int_32"`
	SomeInt64                int64                                       `json:"some_int_64"`
	SomeUint                 uint                                        `json:"some_uint_"`
	SomeUint8                uint8                                       `json:"some_uint_8"`
	SomeUint16               uint16                                      `json:"some_uint_16"`
	SomeUint32               uint32                                      `json:"some_uint_32"`
	SomeUint64               uint64                                      `json:"some_uint_64"`
	SomeFloat32              float32                                     `json:"some_float_32"`
	SomeFloat64              float64                                     `json:"some_float_64"`
	SomeString               string                                      `json:"some_string"`
	AnotherStruct            AnotherTestJSONStruct                       `json:"another_struct"`
	SomeStructSlice          []AnotherTestJSONStruct                     `json:"some_struct_slice"`
	SomeArray                [4]string                                   `json:"some_array"`
	NoNameOverride           string                                      `json:""`
	SomeByte                 byte                                        `json:"some_byte"`
	SomeByteSlice            []byte                                      `json:"some_byte_slice"`
	PtrToStruct              *AnotherTestJSONStruct                      `json:"ptr_to_struct"`
	SliceOfPtrs              []*AnotherTestJSONStruct                    `json:"slice_of_ptrs"`
	SliceOfSlice             [][]AnotherTestJSONStruct                   `json:"slice_of_slice"`
	SliceOfSliceOfSlice      [][][]string                                `json:"slice_of_slice_of_slice"`
	SliceOfSliceOfPtrs       [][]*AnotherTestJSONStruct                  `json:"slice_of_slice_of_ptrs"`
	SomeMap                  map[string]int                              `json:"some_map"`
	SomeMapOfSlice           map[string][]AnotherTestJSONStruct          `json:"some_map_of_slice"`
	SomeMapOfMap             map[string]map[string]AnotherTestJSONStruct `json:"some_map_of_map"`
	ImplementsMarshaler      ImplementsMarshaler                         `json:"implements_marshaler"`
	SliceOfImplsMarsh        []ImplementsMarshaler                       `json:"slice_of_impls_marsh"`
	SliceOfPtrsToImpl        []*ImplementsMarshaler                      `json:"slice_of_ptrs_to_impl"`
	SliceOfSliceOfImplsMarsh [][]ImplementsMarshaler                     `json:"slice_of_slice_of_impls_marsh"`
	SliceOfSliceOfPtrsToImpl [][]*ImplementsMarshaler                    `json:"slice_of_slice_of_ptrs_to_impl"`
	UnknownType              interface{}                                 `json:"unknown_type"`
	StructFromAnotherPackage net.TCPAddr                                 `json:"struct_from_anoter_package"`
}

type AnotherTestJSONStruct struct {
	StringField string `json:"string_field"`
}

type ImplementsMarshaler struct {
	SomeField int `json:"some_field"`
}

func (i ImplementsMarshaler) MarshalJSON() ([]byte, error) {
	return []byte{}, nil
}

func (s *JSONEncodersTestSuite) TestEncoderMethodFor() {
	jsonStruct := TestJSONStruct{}

	expected :=
		`func (e *encodingBuffer) testJSONStructStruct(testJSONStruct TestJSONStruct) {
	e.OpenBrace()

	// "some_bool":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x62, 0x6f, 0x6f, 0x6c, 0x22, 0x3a})
	e.Bool(bool(testJSONStruct.SomeBool))
	e.Comma()

	// "some_int":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x22, 0x3a})
	e.Int(testJSONStruct.SomeInt)
	e.Comma()

	// "some_int_8":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x5f, 0x38, 0x22, 0x3a})
	e.Int8(testJSONStruct.SomeInt8)
	e.Comma()

	// "some_int_16":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x5f, 0x31, 0x36, 0x22, 0x3a})
	e.Int16(testJSONStruct.SomeInt16)
	e.Comma()

	// "some_int_32":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x5f, 0x33, 0x32, 0x22, 0x3a})
	e.Int32(testJSONStruct.SomeInt32)
	e.Comma()

	// "some_int_64":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x5f, 0x36, 0x34, 0x22, 0x3a})
	e.Int64(testJSONStruct.SomeInt64)
	e.Comma()

	// "some_uint_":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x75, 0x69, 0x6e, 0x74, 0x5f, 0x22, 0x3a})
	e.Uint(testJSONStruct.SomeUint)
	e.Comma()

	// "some_uint_8":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x75, 0x69, 0x6e, 0x74, 0x5f, 0x38, 0x22, 0x3a})
	e.Uint8(testJSONStruct.SomeUint8)
	e.Comma()

	// "some_uint_16":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x75, 0x69, 0x6e, 0x74, 0x5f, 0x31, 0x36, 0x22, 0x3a})
	e.Uint16(testJSONStruct.SomeUint16)
	e.Comma()

	// "some_uint_32":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x75, 0x69, 0x6e, 0x74, 0x5f, 0x33, 0x32, 0x22, 0x3a})
	e.Uint32(testJSONStruct.SomeUint32)
	e.Comma()

	// "some_uint_64":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x75, 0x69, 0x6e, 0x74, 0x5f, 0x36, 0x34, 0x22, 0x3a})
	e.Uint64(testJSONStruct.SomeUint64)
	e.Comma()

	// "some_float_32":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x33, 0x32, 0x22, 0x3a})
	e.Float32(float32(testJSONStruct.SomeFloat32))
	e.Comma()

	// "some_float_64":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x36, 0x34, 0x22, 0x3a})
	e.Float64(float64(testJSONStruct.SomeFloat64))
	e.Comma()

	// "some_string":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x3a})
	e.Quote(testJSONStruct.SomeString)
	e.Comma()

	// "another_struct":
	e.Write([]byte{0x22, 0x61, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x22, 0x3a})
	anothertestjsonstructBytes, _ := json.Marshal(testJSONStruct.AnotherStruct)
	e.Write(anothertestjsonstructBytes)
	e.Comma()

	// "some_struct_slice":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SomeStructSlice {
		if index != 0 { e.Comma() }
		e.anotherTestJSONStructStruct(element)
	}
	e.WriteByte(']')
	e.Comma()

	// "some_array":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x61, 0x72, 0x72, 0x61, 0x79, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SomeArray {
		if index != 0 { e.Comma() }
		e.Quote(string(element))
	}
	e.WriteByte(']')
	e.Comma()

	// "nonameoverride":
	e.Write([]byte{0x22, 0x6e, 0x6f, 0x6e, 0x61, 0x6d, 0x65, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x22, 0x3a})
	e.Quote(testJSONStruct.NoNameOverride)
	e.Comma()

	// "some_byte":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x22, 0x3a})
	e.Uint8(testJSONStruct.SomeByte)
	e.Comma()

	// "some_byte_slice":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SomeByteSlice {
		if index != 0 { e.Comma() }
		e.Uint8(uint8(element))
	}
	e.WriteByte(']')
	e.Comma()

	// "ptr_to_struct":
	e.Write([]byte{0x22, 0x70, 0x74, 0x72, 0x5f, 0x74, 0x6f, 0x5f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x22, 0x3a})
		e.anotherTestJSONStructStruct(*testJSONStruct.PtrToStruct)
	e.Comma()

	// "slice_of_ptrs":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x70, 0x74, 0x72, 0x73, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfPtrs {
		if index != 0 { e.Comma() }
		e.anotherTestJSONStructStruct(*element)
	}
	e.WriteByte(']')
	e.Comma()

	// "slice_of_slice":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfSlice {
		if index != 0 { e.Comma() }
	e.WriteByte('[')
	for index, subelement := range element {
		if index != 0 { e.Comma() }
		e.anotherTestJSONStructStruct(subelement)
	}
	e.WriteByte(']')
	}
	e.WriteByte(']')
	e.Comma()

	// "slice_of_slice_of_slice":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfSliceOfSlice {
		if index != 0 { e.Comma() }
	e.WriteByte('[')
	for index, subelement := range element {
		if index != 0 { e.Comma() }
	e.WriteByte('[')
	for index, subsubelement := range subelement {
		if index != 0 { e.Comma() }
		e.Quote(string(subsubelement))
	}
	e.WriteByte(']')
	}
	e.WriteByte(']')
	}
	e.WriteByte(']')
	e.Comma()

	// "slice_of_slice_of_ptrs":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x70, 0x74, 0x72, 0x73, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfSliceOfPtrs {
		if index != 0 { e.Comma() }
	e.WriteByte('[')
	for index, subelement := range element {
		if index != 0 { e.Comma() }
		e.anotherTestJSONStructStruct(*subelement)
	}
	e.WriteByte(']')
	}
	e.WriteByte(']')
	e.Comma()

	// "some_map":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x6d, 0x61, 0x70, 0x22, 0x3a})
	 e.WriteByte('{')
	someMapIterationCount := 0
	for k, v := range testJSONStruct.SomeMap {
		if someMapIterationCount > 0 { e.Comma() }
		someMapIterationCount++
		e.Quote(string(k))
	e.WriteByte(':')
		e.Int(int(v))
	}
	 e.WriteByte('}')
	e.Comma()

	// "some_map_of_slice":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x6d, 0x61, 0x70, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0x3a})
	 e.WriteByte('{')
	someMapOfSliceIterationCount := 0
	for k, v := range testJSONStruct.SomeMapOfSlice {
		if someMapOfSliceIterationCount > 0 { e.Comma() }
		someMapOfSliceIterationCount++
		e.Quote(string(k))
	e.WriteByte(':')
	e.WriteByte('[')
	for index, subv := range v {
		if index != 0 { e.Comma() }
		e.anotherTestJSONStructStruct(subv)
	}
	e.WriteByte(']')
	}
	 e.WriteByte('}')
	e.Comma()

	// "some_map_of_map":
	e.Write([]byte{0x22, 0x73, 0x6f, 0x6d, 0x65, 0x5f, 0x6d, 0x61, 0x70, 0x5f, 0x6f, 0x66, 0x5f, 0x6d, 0x61, 0x70, 0x22, 0x3a})
	 e.WriteByte('{')
	someMapOfMapIterationCount := 0
	for k, v := range testJSONStruct.SomeMapOfMap {
		if someMapOfMapIterationCount > 0 { e.Comma() }
		someMapOfMapIterationCount++
		e.Quote(string(k))
	e.WriteByte(':')
	 e.WriteByte('{')
	vIterationCount := 0
	for subV, subK := range v {
		if vIterationCount > 0 { e.Comma() }
		vIterationCount++
		e.Quote(string(subV))
	e.WriteByte(':')
		e.anotherTestJSONStructStruct(subK)
	}
	 e.WriteByte('}')
	}
	 e.WriteByte('}')
	e.Comma()

	// "implements_marshaler":
	e.Write([]byte{0x22, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x5f, 0x6d, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6c, 0x65, 0x72, 0x22, 0x3a})
	testJSONStructBytes, err := testJSONStruct.ImplementsMarshaler.MarshalJSON()
	if err != nil {
		panic(err)
	}
	e.Write(testJSONStructBytes)
	e.Comma()

	// "slice_of_impls_marsh":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x69, 0x6d, 0x70, 0x6c, 0x73, 0x5f, 0x6d, 0x61, 0x72, 0x73, 0x68, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfImplsMarsh {
		if index != 0 { e.Comma() }
	elementBytes, err := element.MarshalJSON()
	if err != nil {
		panic(err)
	}
	e.Write(elementBytes)
	}
	e.WriteByte(']')
	e.Comma()

	// "slice_of_ptrs_to_impl":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x70, 0x74, 0x72, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x69, 0x6d, 0x70, 0x6c, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfPtrsToImpl {
		if index != 0 { e.Comma() }
	*elementBytes, err := *element.MarshalJSON()
	if err != nil {
		panic(err)
	}
	e.Write(*elementBytes)
	}
	e.WriteByte(']')
	e.Comma()

	// "slice_of_slice_of_impls_marsh":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x69, 0x6d, 0x70, 0x6c, 0x73, 0x5f, 0x6d, 0x61, 0x72, 0x73, 0x68, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfSliceOfImplsMarsh {
		if index != 0 { e.Comma() }
	e.WriteByte('[')
	for index, subelement := range element {
		if index != 0 { e.Comma() }
	subelementBytes, err := subelement.MarshalJSON()
	if err != nil {
		panic(err)
	}
	e.Write(subelementBytes)
	}
	e.WriteByte(']')
	}
	e.WriteByte(']')
	e.Comma()

	// "slice_of_slice_of_ptrs_to_impl":
	e.Write([]byte{0x22, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x5f, 0x6f, 0x66, 0x5f, 0x70, 0x74, 0x72, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x69, 0x6d, 0x70, 0x6c, 0x22, 0x3a})
	e.WriteByte('[')
	for index, element := range testJSONStruct.SliceOfSliceOfPtrsToImpl {
		if index != 0 { e.Comma() }
	e.WriteByte('[')
	for index, subelement := range element {
		if index != 0 { e.Comma() }
	*subelementBytes, err := *subelement.MarshalJSON()
	if err != nil {
		panic(err)
	}
	e.Write(*subelementBytes)
	}
	e.WriteByte(']')
	}
	e.WriteByte(']')
	e.Comma()

	// "unknown_type":
	e.Write([]byte{0x22, 0x75, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a})
	Bytes, _ := json.Marshal(testJSONStruct.UnknownType)
	e.Write(Bytes)
	e.Comma()

	// "struct_from_anoter_package":
	e.Write([]byte{0x22, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x61, 0x6e, 0x6f, 0x74, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x22, 0x3a})
	tcpaddrBytes, _ := json.Marshal(testJSONStruct.StructFromAnotherPackage)
	e.Write(tcpaddrBytes)

	e.CloseBrace()
}

`
	s.Nil(s.generator.EncoderMethodFor(jsonStruct))
	s.Equal(expected, s.generator.String())

	// Passing in a pointer to a struct also works
	s.generator.Reset()
	s.Nil(s.generator.EncoderMethodFor(&jsonStruct))
	s.Equal(expected, s.generator.String())

	// Structs with no json tags are skipped
	s.generator.Reset()
	s.Nil(s.generator.EncoderMethodFor(struct{ SomeField string }{}))
	s.Equal("", s.generator.String())

	// Unsupported kinds of types return an error
	s.generator.Reset()
	s.NotNil(s.generator.EncoderMethodFor(1))
	s.NotNil(s.generator.EncoderMethodFor("foo"))
	s.NotNil(s.generator.EncoderMethodFor(1.23))
	s.NotNil(s.generator.EncoderMethodFor([]int{1, 2, 3}))
	s.Equal("", s.generator.String())
}
